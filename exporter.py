import re
import collections
import sys
import shutil

pattern = re.compile('//!export(.*)$')
method_decl = re.compile('(final )?(static)?( final)? ([a-zA-Z0-9_]+) ([a-zA-Z0-9_]+) ?\((.*)\)')

content = '''// AUTOGENERATED by exporter.py from %(name)s.java
package pyjvm;

public final class %(name)sClass extends Type {
	private %(name)sClass() {}

	public static final StringDict dict;
	public static final %(name)sClass instance = new %(name)sClass();
	
	static {
		if("%(name)s".equals("NativeObj") || "%(name)s".equals("UserObj"))
			dict = new StringDict();
		else
			dict = NativeObjClass.dict.copy();
		%(content)s
	}
	public final StringDict getDict() {
		return dict;
	}
	public final Obj getEntry(int name) {
		return dict.get(name);
	}
}
'''

entry_template = '''
		dict.put("%(name)s", new Obj() {
			public Obj call(Obj[] args) {
				%(check)s
				%(code)s;
			}
		});'''

method_entry_template = '''
		dict.put("%(name)s", new Method() {
			public Obj callMethod(Obj self, Obj[] args) {
				%(check)s
				%(code)s;
			}
		});'''

call_method_template = '%s.%s(%s)'
arg_template = "args[%d]"

check_count = '''if(args.length != %d) {
					throw new ScriptError(ScriptError.TypeError, "Bad number of arguments");
				}'''

converters = {
	'int': 'return SInt.get(%s)',
	'Obj': 'return %s',
	'void': '%s; return None'
}
unconverters = {
	'int': '%s.intValue()',
	'Obj': '%s'
}

Method = collections.namedtuple('method', 'static return_type name args')

def parse_method(line):
	m = method_decl.search(line)
	if not m:
		raise ValueError('Invalid method declaration: %s' % line.strip())
	_, static, _, type, name, args = m.groups()
	
	if args.strip():
		arg_list = [ arg.split() for arg in args.split(',') ]
	else:
		arg_list = []
	
	return Method(static=(static=='static'), return_type=type, name=name, args=arg_list)

def backup(fn):
	try:
		shutil.copy(fn, '.backup-' + fn.encode('hex') + '~')
	except IOError:
		pass

def convert(type, val):
	return converters[type] % val

def unconvert(type, val):
	return unconverters[type] % val

def create_name(name):
	if name.endswith('_'):
		return name[:-1]
	return name

def format_entry(class_name, entry, is_direct, as_name):
	if entry.static:
		object = class_name
		entry_tmpl = entry_template
	else:
		object = '((%s)self)' % class_name
		entry_tmpl = method_entry_template
	
	if not is_direct:
		results = []
		for i, (type, name) in enumerate(entry.args):
			results.append(unconvert(type, arg_template % i ))
		result = ', '.join(results)
	
		return entry_tmpl % dict(
			name=as_name,
			check=check_count % len(entry.args),
			code=convert(
				entry.return_type,
				call_method_template % (object, entry.name, result)
			)
		)
	else:
		return entry_tmpl % dict(
			name=as_name,
			check = '// direct',
			code=convert(
				entry.return_type,
				call_method_template % (object, entry.name, 'args')
			)
		)

def format(name, data):
	entries = ''.join([
		format_entry(name, entry, is_direct, as_name)
		for entry, is_direct, as_name in data
	])
	return content % dict(name=name, content=entries)

def parse_method_export(rest, name):
	rest_split = rest.split()
	if len(rest_split) == 2:
		spec, as_name = rest_split
	elif len(rest_split) == 1:
		spec = rest_split[0]
		as_name = create_name(name)
	else:
		spec = ''
		as_name = create_name(name)
	return spec, as_name

def run(lines):
	def write():
		if output:
			output.write(format(name, data))
			output.close()
	
	output = None
	data = []
	name = None
	for line in lines:
		if not pattern.search(line):
			continue
		match = pattern.search(line)
		rest = match.group(1).strip()
		if 'class' in line:
			fn = 'pyjvm/%sClass.java' % rest
			name = rest
			backup(fn)
			write()
			output = open(fn, 'w')
		else:
			method = parse_method(line)
			spec, as_name = parse_method_export(rest, method.name)
			if not output:
				raise ValueError('Method declaration before class declaration')
			data.append((method, spec == 'direct', as_name))
	write()

if __name__ == '__main__':
	run(sys.stdin)