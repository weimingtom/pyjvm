# Copyright (C) 2011 by Michal Zielinski
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import os
os.chdir(os.path.join(os.path.dirname(__file__), '..', 'java'))

import re
import collections
import sys
import shutil

pattern = re.compile('//!export(.*)$')
method_decl = re.compile('(final )?(static)?( final)? ([a-zA-Z0-9_]+) ([a-zA-Z0-9_]+) ?\((.*)\)')

content = '''// AUTOGENERATED by exporter.py from %(name)s.java
package pyjvm%(pkg)s;

import pyjvm.*;

public final class %(name)sClass extends Type {
	private %(name)sClass() {}

	public static final StringDict dict;
	public static final %(name)sClass instance = new %(name)sClass();
	public static final Obj constructor%(constructor)s;
	
	static {
		if("%(name)s".equals("NativeObj") || "%(name)s".equals("UserObj"))
			dict = new StringDict();
		else
			dict = %(baseclass)sClass.dict.copy();
		%(content)s
	}
	public final StringDict getDict() {
		return dict;
	}
	public final Obj getEntry(int name) {
		return dict.get(name);
	}
	public final Obj call(Obj[] args) {
		if(constructor == null)
			throw new ScriptError(ScriptError.TypeError, "Object uninitializable");
		return constructor.call(args);
	}
}
'''

entry_template = '''
		dict.put("%(name)s", new Obj() {
			public Obj call(Obj[] args) {
				%(check)s
				%(code)s;
			}
		});'''

method_entry_template = '''
		dict.put("%(name)s", new Method() {
			public Obj callMethod(Obj self, Obj[] args) {
				%(check)s
				%(code)s;
			}
		});'''

constructor_template = '''
		constructor = new Obj() {
			public Obj call(Obj[] args)  {
				%(check)s
				%(code)s;
			}
		};
		'''

call_method_template = '%s.%s(%s)'
arg_template = "args[%d]"

check_count = '''if(args.length != %(cnt)d) {
					throw new ScriptError(ScriptError.TypeError, "Bad number of arguments (expected %(cnt)d, got " + args.length + ")");
				}'''

converters = {
	'int': 'return SInt.get(%s)',
	'Obj': 'return %s',
	'void': '%s; return None',
	'boolean': 'return %s? SBool.True: SBool.False',
}
unconverters = {
	'int': '%s.intValue()',
	'Obj': '%s'
}

Method = collections.namedtuple('method', 'static return_type name args')

def parse_method(line):
	m = method_decl.search(line)
	if not m:
		raise ValueError('Invalid method declaration: %s' % line.strip())
	_, static, _, type, name, args = m.groups()
	
	if args.strip():
		arg_list = [ arg.split() for arg in args.split(',') ]
	else:
		arg_list = []
	
	return Method(static=(static=='static'), return_type=type, name=name, args=arg_list)

def backup(fn):
	try:
		shutil.copy(fn, '.backup-' + fn.encode('hex') + '~')
	except IOError:
		pass

def convert(type, val):
	return converters.get(type, 'return %s') % val

def unconvert(type, val):
	return unconverters.get(type, '%s') % val

def create_name(name):
	if name.endswith('_'):
		return name[:-1]
	return name

def format_entry(class_name, entry, is_direct, as_name):
	if as_name == '<new>':
		object = class_name
		entry_tmpl = constructor_template
	elif entry.static:
		object = class_name
		entry_tmpl = entry_template
	else:
		object = '((%s)self)' % class_name
		entry_tmpl = method_entry_template
	
	if not is_direct:
		results = []
		for i, (type, name) in enumerate(entry.args):
			results.append(unconvert(type, arg_template % i ))
		result = ', '.join(results)
	
		return entry_tmpl % dict(
			name=as_name,
			check=check_count % dict(cnt= len(entry.args)),
			code=convert(
				entry.return_type,
				call_method_template % (object, entry.name, result)
			)
		)
	else:
		return entry_tmpl % dict(
			name=as_name,
			check = '// direct',
			code=convert(
				entry.return_type,
				call_method_template % (object, entry.name, 'args')
			)
		)

def format(pkg, name, baseclass, data):
	entries = ''.join([
		format_entry(name, entry, is_direct, as_name)
		for entry, is_direct, as_name in data
	])
	has_constructor = any( as_name == '<new>' for entry, is_direct, as_name in data )
	return content % dict(name=name, content=entries,
						  constructor='' if has_constructor else ' = null',
						  baseclass=baseclass, pkg=pkg)

def parse_method_export(rest, name):
	rest_split = rest.split()
	if len(rest_split) == 2:
		spec, as_name = rest_split
	elif len(rest_split) == 1:
		spec = rest_split[0]
		as_name = create_name(name)
	else:
		spec = ''
		as_name = create_name(name)
	return spec, as_name

def run(lines):
	def write():
		if output:
			output.write(format(pkg, name, baseclass, data))
			output.close()
	
	output = None
	data = []
	name = None
	baseclass = None
	for line in lines:
		if not pattern.search(line):
			continue
		match = pattern.search(line)
		rest = match.group(1).strip()
		if ' class' in line or line.startswith('class'):
			restsplit = rest.split()
			if len(restsplit) == 1: restsplit.append('NativeObj')
			name, baseclass = restsplit
			fn = 'pyjvm/%sClass.java' % (name.replace('.', '/'))
			if '.' in name:
				pkg, name = name.rsplit('.', 1)
				pkg = '.' + pkg
			else:
				pkg = ''
			backup(fn)
			write()
			output = open(fn, 'w')
		else:
			method = parse_method(line)
			spec, as_name = parse_method_export(rest, method.name)
			if not output:
				raise ValueError('Method declaration before class declaration')
			data.append((method, spec == 'direct', as_name))
	write()

if __name__ == '__main__':
	run(sys.stdin)