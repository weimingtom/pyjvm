import sys
sys.stdout = open('pyjvm/BinOpInstrs.java', 'w')

names = ['add', 'sub', 'mul', 'floordiv', 'div', 'truediv']
names = [ (n, n, 'r' + n) for n in names ]

names += [('==', 'isEqual', 'isEqual')]
names += [
	(symbol, 'i' + method, 'r' + method)
	for symbol, method in [
		('+=', 'add'), ('-=', 'sub')
	]
]

print '''// AUTOGENERATED by genops.py
package pyjvm;
public final class BinOpInstrs {'''

def capitalize(str):
	return str[0].upper() + str[1:]

for op, name, symmetric in names:
	cname = capitalize(name)
	s = '''
	public static final class %(cname)s extends GenericInstrs.BinOp {
		public Instr run(Frame frame) {
			Obj a = frame.reg[inreg0];
			Obj b = frame.reg[inreg1];
			Obj result = a.%(name)s(frame, b);
			if(result == NotImplemented) {
				result = b.%(symmetric)s(frame, a);
				if(result == NotImplemented)
					this.operatorFailed(a, b, "%(op)s");
			}
			frame.reg[outreg0] = result;
			return next;
		}
	}''' % locals()
	if name == 'isEqual':
		s = s.replace('NotImplemented', 'null')
	print s

print '''
	public static abstract class BinOpFactory extends Obj {
		public abstract GenericInstrs.BinOp create();
	}
	
	public static final StringDict binOpTypes = new StringDict();
	
	static {'''

for op, name, symmetric in names:
	cname = capitalize(name)
	print '''
		binOpTypes.put("%(op)s", new BinOpFactory(){
			public GenericInstrs.BinOp create() {
				return new %(cname)s();
			}
		});''' % locals()

print '''
	}
}'''
sys.stdout.close()
